Challenge3: Verification of riscv_buggy RTL.

    The Given RTL is RTL_BUGGY for which we don't have access. To verify RTL without Looking into implementation removes the possibility of finding bugs by going through RTL model.
	We are using a spike simulator to verify the RTL. here we don't have any SV/UVM based testbench. And no waveforms are also available so we will try to use the RCD(Register Change Dump) comparison method  between golden model and RTL. We will generate the Test Pattern with help of AAPG (automatic assembly pattern generator) from SHAKTI IITM. The steps involved in verification are mentioned below:

1. Test generation : generating Pattern with help of AAPG.
2. Test compilation: compiling generated Instructions and generating .elf(executable link format) files
3. Test disassembly : generating assembly code from .elf file for our reference
4. Spike run: running Spike simulator on generated .elf file.
5. Simulation: converting the .elf file to hex code and loading it into rtl and generating results.
6. Compare: compare the generated dump with reference dump generated by spike simulator. If thereâ€™s a difference theres bug in RTL.  

Tests RUN:
1.  compute instruction random test -- test failed
2.  ctrl instruction random test with data/fence instrctions - test was clean
3.  data instruction random test  -- Test was clean
4.  exceptions instruction test alone -- test was clean
5.  fence instruction test -- test was clean
6.  CSR instructions test --tets fail
7.  All compute,ctrl,data,fence,exceptions in same test. --test fail .
8.  privilege mode change test -- test failed
9.  Exceptions test --test clean,

i should have tested data overflow, address overflow, address shifting by more than 32 bits jump more than boundry limit instructions but with AAPG everything is random and i couldnt find a way in aapg documentation to generate a particular sceanrio


BUGS FOUND:
1. OR/ORi operation in cpu not giving correct result-- 
    As the OR/ORi operations are giving wrong result which is updated in destination register. I feel the problem will be with OR logic implementation in RTL.
    there are other chances as well like incorrect decoding of instruction/reading incorrect values from the registers but i think these are not the issue because other register reads are happening correctly and other instructions are also executed properly so mostly there is no instruction decoding issue also but to confirm i should check the waveform or the RTL to confirm. 


2. XOR/XORi operation in cpu not giving correct result--
    here also similar problem as OR only. here also i suspect the problem with XOR implementation. there could be separate xor implementation in RTL then that block needs rtl change. or if the XOR is calculation OR from OR logic then its problem with OR implementation only.

3. Probem with priv-mode change
    when i'm testing the RTL with mode change setting i'm seeing some issue with the mode change after mret instruction is executed. with my understanding from the log, the cpu should go into supervisor mode but its going to user mode so in rtl the implementaion of mode change is not coded properly. with complete log analysis i found theres problem in switching mode of operation from machine to supervisor. the simulator changes mode from M to S but rtl is changing from M to U.

4. Interrupt handling issue:
    when i'm trying interrupts with csr instructions i'm seeing theres some issue afte mret execution. the mret instruction is used to return from a machine-mode trap handler to the previous machine-mode context. After the mret instruction is executed, the CPU should restore the machine-mode registers and program counter, transitioning back to machine mode. but that is not happening and we are seeing different behaviour. with waveform and rtl visibility i can check the issue in detail. either of thr following can be the reason behind wrong execution in cpu: 1.Register Corruption: if cpu dosent restore machine mode register correctly because of corruption in reg value then it could be a problem. or 2. Exception Handling Problems or 3. Pipeline or Timing Problems.

5. 








    